{
  boolean legacy=parentCategoryLegacyModeService.isLegacyMode();
  if (!legacy) {
    FilterAndSortCriteria fsc=cto.getCriteriaMap().get("defaultCategory");
    if (fsc != null) {
      List<String> filterValues=fsc.getFilterValues();
      cto.getCriteriaMap().remove("defaultCategory");
      List<Long> transformedValues=BLCCollectionUtils.collectList(filterValues,new TypedTransformer<Long>(){
        @Override public Long transform(        Object input){
          return Long.parseLong(((String)input));
        }
      }
);
      CriteriaBuilder builder=dynamicEntityDao.getStandardEntityManager().getCriteriaBuilder();
      CriteriaQuery<Long> criteria=builder.createQuery(Long.class);
      Root<CategoryProductXrefImpl> root=criteria.from(CategoryProductXrefImpl.class);
      criteria.select(root.get("product").get("id").as(Long.class));
      List<Predicate> restrictions=new ArrayList<Predicate>();
      restrictions.add(builder.equal(root.get("defaultReference"),Boolean.TRUE));
      restrictions.add(root.get("category").get("id").in(transformedValues));
      QueryUtils.notArchived(builder,restrictions,root,"archiveStatus");
      criteria.where(restrictions.toArray(new Predicate[restrictions.size()]));
      TypedQuery<Long> query=dynamicEntityDao.getStandardEntityManager().createQuery(criteria);
      List<Long> productIds=query.getResultList();
      productIds=sandBoxHelper.mergeCloneIds(ProductImpl.class,productIds.toArray(new Long[productIds.size()]));
      if (productIds.size() == 0) {
        return new DynamicResultSet(null,new Entity[0],0);
      }
      if (productIds.size() <= queryLimit) {
        FilterMapping filterMapping=new FilterMapping().withFieldPath(new FieldPath().withTargetProperty("id")).withDirectFilterValues(productIds).withRestriction(new Restriction().withPredicateProvider(new PredicateProvider(){
          @Override public Predicate buildPredicate(          CriteriaBuilder builder,          FieldPathBuilder fieldPathBuilder,          From root,          String ceilingEntity,          String fullPropertyName,          Path explicitPath,          List directValues){
            return explicitPath.in(directValues);
          }
        }
));
        cto.getAdditionalFilterMappings().add(filterMapping);
      }
 else {
        String joined=StringUtils.join(transformedValues,',');
        LOG.warn(String.format("Skipping default category filtering for product fetch query since there are " + "more than " + queryLimit + " products found to belong to the selected default categories(%s). This is a "+ "filter query limitation.",joined));
      }
    }
  }
  cto.getNonCountAdditionalFilterMappings().add(new FilterMapping().withDirectFilterValues(new EmptyFilterValues()).withRestriction(new Restriction().withPredicateProvider(new PredicateProvider(){
    public Predicate buildPredicate(    CriteriaBuilder builder,    FieldPathBuilder fieldPathBuilder,    From root,    String ceilingEntity,    String fullPropertyName,    Path explicitPath,    List directValues){
      root.fetch("defaultSku",JoinType.LEFT);
      root.fetch("defaultCategory",JoinType.LEFT);
      return null;
    }
  }
)));
  return helper.getCompatibleModule(OperationType.BASIC).fetch(persistencePackage,cto);
}
