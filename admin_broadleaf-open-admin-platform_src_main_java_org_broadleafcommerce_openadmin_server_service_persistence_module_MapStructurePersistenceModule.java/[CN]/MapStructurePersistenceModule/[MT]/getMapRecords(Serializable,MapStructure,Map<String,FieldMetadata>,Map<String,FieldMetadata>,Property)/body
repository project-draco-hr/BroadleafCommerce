{
  List<String> mapFieldKeys=new ArrayList<String>();
  String mapProperty=mapStructure.getMapProperty();
  for (  Map.Entry<String,FieldMetadata> entry : ceilingMergedProperties.entrySet()) {
    if (entry.getKey().startsWith(mapProperty + FieldManager.MAPFIELDSEPARATOR)) {
      mapFieldKeys.add(entry.getKey().substring(entry.getKey().indexOf(FieldManager.MAPFIELDSEPARATOR) + FieldManager.MAPFIELDSEPARATOR.length(),entry.getKey().length()));
    }
  }
  Collections.sort(mapFieldKeys);
  FieldManager fieldManager=getFieldManager();
  Map map;
  try {
    map=(Map)fieldManager.getFieldValue(record,mapProperty);
  }
 catch (  FieldNotAvailableException e) {
    throw new IllegalArgumentException(e);
  }
  List<Entity> entities=new ArrayList<Entity>(map.size());
  for (  Object key : map.keySet()) {
    if (key instanceof String && mapFieldKeys.contains(key)) {
      continue;
    }
    Entity entityItem=new Entity();
    entityItem.setType(new String[]{record.getClass().getName()});
    entities.add(entityItem);
    List<Property> props=new ArrayList<Property>();
    Property propertyItem=new Property();
    propertyItem.setName(mapStructure.getKeyPropertyName());
    props.add(propertyItem);
    String strVal;
    if (Date.class.isAssignableFrom(key.getClass())) {
      strVal=getSimpleDateFormatter().format((Date)key);
    }
 else     if (Timestamp.class.isAssignableFrom(key.getClass())) {
      strVal=getSimpleDateFormatter().format(new Date(((Timestamp)key).getTime()));
    }
 else     if (Calendar.class.isAssignableFrom(key.getClass())) {
      strVal=getSimpleDateFormatter().format(((Calendar)key).getTime());
    }
 else     if (Double.class.isAssignableFrom(key.getClass())) {
      strVal=getDecimalFormatter().format(key);
    }
 else     if (BigDecimal.class.isAssignableFrom(key.getClass())) {
      strVal=getDecimalFormatter().format(key);
    }
 else {
      strVal=key.toString();
    }
    propertyItem.setValue(strVal);
    PersistentClass persistentClass=persistenceManager.getDynamicEntityDao().getPersistentClass(mapStructure.getValueClassName());
    if (persistentClass == null) {
      Property temp=new Property();
      temp.setName(((SimpleValueMapStructure)mapStructure).getValuePropertyName());
      temp.setValue(String.valueOf(map.get(key)));
      props.add(temp);
    }
 else {
      extractPropertiesFromPersistentEntity(valueMergedProperties,(Serializable)map.get(key),props);
    }
    if (symbolicIdProperty != null) {
      props.add(symbolicIdProperty);
    }
    Property[] properties=new Property[props.size()];
    properties=props.toArray(properties);
    entityItem.setProperties(properties);
  }
  return entities.toArray(new Entity[entities.size()]);
}
