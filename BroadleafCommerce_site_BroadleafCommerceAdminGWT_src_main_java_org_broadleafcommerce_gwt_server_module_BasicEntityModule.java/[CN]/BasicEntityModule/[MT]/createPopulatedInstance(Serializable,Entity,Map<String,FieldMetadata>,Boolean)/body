{
  for (  Property property : entity.getProperties()) {
    String originalPropertyName=new String(property.getName());
    if (PropertyUtils.getPropertyDescriptor(instance,property.getName()) == null) {
      if (property.getName().startsWith("is")) {
        property.setName(property.getName().substring(2,3).toLowerCase() + property.getName().substring(3,property.getName().length()));
      }
    }
    if (PropertyUtils.getPropertyDescriptor(instance,property.getName()) == null) {
      LOG.warn("Unable to find a bean property for the reported property: " + originalPropertyName + ". Ignoring property.");
      continue;
    }
    Class<?> returnType=PropertyUtils.getPropertyDescriptor(instance,property.getName()).getPropertyType();
    String value=property.getValue();
    if (value != null && mergedProperties.get(originalPropertyName) != null) {
switch (mergedProperties.get(originalPropertyName).getFieldType()) {
case BOOLEAN:
        PropertyUtils.setProperty(instance,property.getName(),Boolean.valueOf(value));
      break;
case DATE:
    PropertyUtils.setProperty(instance,property.getName(),dateFormat.parse(value));
  break;
case DECIMAL:
if (BigDecimal.class.isAssignableFrom(returnType)) {
  PropertyUtils.setProperty(instance,property.getName(),new BigDecimal((Double)decimalFormat.parse(value)));
}
 else {
  PropertyUtils.setProperty(instance,property.getName(),(Double)decimalFormat.parse(value));
}
break;
case MONEY:
PropertyUtils.setProperty(instance,property.getName(),new Money((Double)decimalFormat.parse(value)));
break;
case INTEGER:
if (int.class.isAssignableFrom(returnType) || Integer.class.isAssignableFrom(returnType)) {
PropertyUtils.setProperty(instance,property.getName(),Integer.valueOf(value));
}
 else if (byte.class.isAssignableFrom(returnType) || Byte.class.isAssignableFrom(returnType)) {
PropertyUtils.setProperty(instance,property.getName(),Byte.valueOf(value));
}
 else if (short.class.isAssignableFrom(returnType) || Short.class.isAssignableFrom(returnType)) {
PropertyUtils.setProperty(instance,property.getName(),Short.valueOf(value));
}
 else if (long.class.isAssignableFrom(returnType) || Long.class.isAssignableFrom(returnType)) {
PropertyUtils.setProperty(instance,property.getName(),Long.valueOf(value));
}
break;
case STRING:
PropertyUtils.setProperty(instance,property.getName(),value);
break;
case EMAIL:
PropertyUtils.setProperty(instance,property.getName(),value);
break;
case FOREIGN_KEY:
{
Serializable foreignInstance=dynamicEntityDao.retrieve(Class.forName(entity.getType()),Long.valueOf(value));
if (Collection.class.isAssignableFrom(returnType)) {
@SuppressWarnings("rawtypes") Collection collection=(Collection)PropertyUtils.getProperty(instance,property.getName());
if (!collection.contains(foreignInstance)) {
collection.add(foreignInstance);
}
}
 else if (Map.class.isAssignableFrom(returnType)) {
throw new RuntimeException("Map structures are not supported for foreign key fields.");
}
 else {
PropertyUtils.setProperty(instance,property.getName(),foreignInstance);
}
break;
}
case ADDITIONAL_FOREIGN_KEY:
{
Serializable foreignInstance=dynamicEntityDao.retrieve(Class.forName(entity.getType()),Long.valueOf(value));
if (Collection.class.isAssignableFrom(returnType)) {
@SuppressWarnings("rawtypes") Collection collection=(Collection)PropertyUtils.getProperty(instance,property.getName());
if (!collection.contains(foreignInstance)) {
collection.add(foreignInstance);
}
}
 else if (Map.class.isAssignableFrom(returnType)) {
throw new RuntimeException("Map structures are not supported for foreign key fields.");
}
 else {
PropertyUtils.setProperty(instance,property.getName(),foreignInstance);
}
break;
}
case ID:
if (setId) {
PropertyUtils.setProperty(instance,property.getName(),Long.valueOf(value));
}
break;
}
}
}
return instance;
}
