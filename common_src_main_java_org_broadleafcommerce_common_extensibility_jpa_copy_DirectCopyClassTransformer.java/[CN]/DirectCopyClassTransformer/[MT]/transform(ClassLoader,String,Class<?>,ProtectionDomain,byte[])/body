{
  CtClass clazz=null;
  try {
    boolean mySkipOverlaps=skipOverlaps;
    boolean myRenameMethodOverlaps=renameMethodOverlaps;
    String convertedClassName=className.replace('/','.');
    ClassPool classPool=null;
    String xformKey=convertedClassName;
    String[] xformVals=null;
    Boolean[] xformSkipOverlaps=null;
    Boolean[] xformRenameMethodOverlaps=null;
    if (!xformTemplates.isEmpty()) {
      if (xformTemplates.containsKey(xformKey)) {
        xformVals=xformTemplates.get(xformKey).split(",");
        classPool=ClassPool.getDefault();
        clazz=classPool.makeClass(new ByteArrayInputStream(classfileBuffer),false);
      }
    }
 else {
      if (annotationTransformedClasses.contains(convertedClassName)) {
        logger.warn(convertedClassName + " has already been transformed by a previous instance of DirectCopyTransfomer. " + "Skipping this annotation based transformation. Generally, annotation-based transformation is handled "+ "by bean id blAnnotationDirectCopyClassTransformer with template tokens being added to "+ "blDirectCopyTransformTokenMap via EarlyStageMergeBeanPostProcessor.");
      }
      boolean isValidPattern=true;
      List<DirectCopyIgnorePattern> matchedPatterns=new ArrayList<DirectCopyIgnorePattern>();
      for (      DirectCopyIgnorePattern pattern : ignorePatterns) {
        boolean isPatternMatch=false;
        for (        String patternString : pattern.getPatterns()) {
          isPatternMatch=convertedClassName.matches(patternString);
          if (isPatternMatch) {
            break;
          }
        }
        if (isPatternMatch) {
          matchedPatterns.add(pattern);
        }
        isValidPattern=!(isPatternMatch && pattern.getTemplateTokenPatterns() == null);
        if (!isValidPattern) {
          return null;
        }
      }
      if (isValidPattern) {
        classPool=ClassPool.getDefault();
        clazz=classPool.makeClass(new ByteArrayInputStream(classfileBuffer),false);
        List<?> attributes=clazz.getClassFile().getAttributes();
        Iterator<?> itr=attributes.iterator();
        List<String> templates=new ArrayList<String>();
        List<Boolean> skips=new ArrayList<Boolean>();
        List<Boolean> renames=new ArrayList<Boolean>();
        check: {
          while (itr.hasNext()) {
            Object object=itr.next();
            if (AnnotationsAttribute.class.isAssignableFrom(object.getClass())) {
              AnnotationsAttribute attr=(AnnotationsAttribute)object;
              Annotation[] items=attr.getAnnotations();
              for (              Annotation annotation : items) {
                String typeName=annotation.getTypeName();
                if (typeName.equals(DirectCopyTransform.class.getName())) {
                  ArrayMemberValue arrayMember=(ArrayMemberValue)annotation.getMemberValue("value");
                  for (                  MemberValue arrayMemberValue : arrayMember.getValue()) {
                    AnnotationMemberValue member=(AnnotationMemberValue)arrayMemberValue;
                    Annotation memberAnnot=member.getValue();
                    ArrayMemberValue annot=(ArrayMemberValue)memberAnnot.getMemberValue("templateTokens");
                    for (                    MemberValue memberValue : annot.getValue()) {
                      String val=((StringMemberValue)memberValue).getValue();
                      if (val != null && templateTokens.containsKey(val)) {
                        templateCheck: {
                          for (                          DirectCopyIgnorePattern matchedPattern : matchedPatterns) {
                            for (                            String ignoreToken : matchedPattern.getTemplateTokenPatterns()) {
                              if (val.matches(ignoreToken)) {
                                break templateCheck;
                              }
                            }
                          }
                          templates.add(templateTokens.get(val));
                        }
                      }
                    }
                    BooleanMemberValue skipAnnot=(BooleanMemberValue)memberAnnot.getMemberValue("skipOverlaps");
                    if (skipAnnot != null) {
                      skips.add(skipAnnot.getValue());
                    }
 else {
                      skips.add(mySkipOverlaps);
                    }
                    BooleanMemberValue renameAnnot=(BooleanMemberValue)memberAnnot.getMemberValue("renameMethodOverlaps");
                    if (renameAnnot != null) {
                      renames.add(renameAnnot.getValue());
                    }
 else {
                      renames.add(myRenameMethodOverlaps);
                    }
                  }
                  xformVals=templates.toArray(new String[templates.size()]);
                  xformSkipOverlaps=skips.toArray(new Boolean[skips.size()]);
                  xformRenameMethodOverlaps=renames.toArray(new Boolean[renames.size()]);
                  break check;
                }
              }
            }
          }
        }
      }
    }
    if (xformVals != null && xformVals.length > 0) {
      logger.lifecycle(LifeCycleEvent.START,String.format("Transform - Copying into [%s] from [%s]",xformKey,StringUtils.join(xformVals,",")));
      clazz.defrost();
      int index=0;
      for (      String xformVal : xformVals) {
        String trimmed=xformVal.trim();
        classPool.appendClassPath(new LoaderClassPath(Class.forName(trimmed).getClassLoader()));
        CtClass template=classPool.get(trimmed);
        CtClass[] interfacesToCopy=template.getInterfaces();
        for (        CtClass i : interfacesToCopy) {
          checkInterfaces: {
            CtClass[] myInterfaces=clazz.getInterfaces();
            for (            CtClass myInterface : myInterfaces) {
              if (myInterface.getName().equals(i.getName())) {
                if (xformSkipOverlaps[index]) {
                  break checkInterfaces;
                }
 else {
                  throw new RuntimeException("Duplicate interface detected " + myInterface.getName());
                }
              }
            }
            logger.debug(String.format("Adding interface [%s]",i.getName()));
            clazz.addInterface(i);
          }
        }
        ClassFile classFile=clazz.getClassFile();
        ClassFile templateFile=template.getClassFile();
        ConstPool constantPool=classFile.getConstPool();
        buildClassLevelAnnotations(classFile,templateFile,constantPool);
        CtField[] fieldsToCopy=template.getDeclaredFields();
        for (        CtField field : fieldsToCopy) {
          if (field.hasAnnotation(NonCopied.class)) {
            logger.debug(String.format("Not adding field [%s]",field.getName()));
          }
 else {
            try {
              clazz.getDeclaredField(field.getName());
              if (xformSkipOverlaps[index]) {
                logger.debug(String.format("Skipping overlapped field [%s]",field.getName()));
                continue;
              }
            }
 catch (            NotFoundException e) {
            }
            logger.debug(String.format("Adding field [%s]",field.getName()));
            CtField copiedField=new CtField(field,clazz);
            boolean defaultConstructorFound=false;
            String implClass=getImplementationType(field.getType().getName());
            try {
              CtConstructor[] implConstructors=classPool.get(implClass).getConstructors();
              if (implConstructors != null) {
                for (                CtConstructor cons : implConstructors) {
                  if (cons.getParameterTypes().length == 0) {
                    defaultConstructorFound=true;
                    break;
                  }
                }
              }
            }
 catch (            NotFoundException e) {
            }
            if (defaultConstructorFound) {
              clazz.addField(copiedField,"new " + implClass + "()");
            }
 else {
              clazz.addField(copiedField);
            }
          }
        }
        CtMethod[] methodsToCopy=template.getDeclaredMethods();
        for (        CtMethod method : methodsToCopy) {
          if (method.hasAnnotation(NonCopied.class)) {
            logger.debug(String.format("Not adding method [%s]",method.getName()));
          }
 else {
            try {
              CtClass[] paramTypes=method.getParameterTypes();
              CtMethod originalMethod=clazz.getDeclaredMethod(method.getName(),paramTypes);
              if (xformSkipOverlaps[index]) {
                logger.debug(String.format("Skipping overlapped method [%s]",methodDescription(originalMethod)));
                continue;
              }
              if (transformedMethods.contains(methodDescription(originalMethod))) {
                throw new RuntimeException("Method already replaced " + methodDescription(originalMethod));
              }
 else {
                logger.debug(String.format("Marking as replaced [%s]",methodDescription(originalMethod)));
                transformedMethods.add(methodDescription(originalMethod));
              }
              logger.debug(String.format("Removing method [%s]",method.getName()));
              if (xformRenameMethodOverlaps[index]) {
                originalMethod.setName(renameMethodPrefix + method.getName());
              }
 else {
                clazz.removeMethod(originalMethod);
              }
            }
 catch (            NotFoundException e) {
            }
            logger.debug(String.format("Adding method [%s]",method.getName()));
            CtMethod copiedMethod=new CtMethod(method,clazz,null);
            clazz.addMethod(copiedMethod);
          }
        }
        index++;
      }
      if (xformTemplates.isEmpty()) {
        annotationTransformedClasses.add(convertedClassName);
      }
      logger.lifecycle(LifeCycleEvent.END,String.format("Transform - Copying into [%s] from [%s]",xformKey,StringUtils.join(xformVals,",")));
      return clazz.toBytecode();
    }
  }
 catch (  ClassCircularityError error) {
    error.printStackTrace();
    throw error;
  }
catch (  Exception e) {
    throw new RuntimeException("Unable to transform class",e);
  }
 finally {
    if (clazz != null) {
      clazz.detach();
    }
  }
  return null;
}
