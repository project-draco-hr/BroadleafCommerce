{
  String ceilingEntityFullyQualifiedClassname=persistencePackage.getCeilingEntityFullyQualifiedClassname();
  try {
    Long fulfillmentLocationId=Long.parseLong(persistencePackage.getCustomCriteria()[1]);
    FulfillmentLocation fulfillmentLocation=(FulfillmentLocation)dynamicEntityDao.retrieve(FulfillmentLocationImpl.class,fulfillmentLocationId);
    List<Sku> skus=inventoryService.readSkusNotAtFulfillmentLocation(fulfillmentLocation);
    CollectionUtils.filter(skus,new Predicate(){
      @Override public boolean evaluate(      Object object){
        Sku sku=(Sku)object;
        return InventoryType.BASIC.equals(sku.getInventoryType()) || (sku.getProduct().getDefaultCategory() != null && InventoryType.BASIC.equals(sku.getProduct().getDefaultCategory().getInventoryType()));
      }
    }
);
    PersistencePerspective persistencePerspective=persistencePackage.getPersistencePerspective();
    Map<String,FieldMetadata> originalProps=helper.getSimpleMergedProperties(Sku.class.getName(),persistencePerspective);
    Entity[] payload=helper.getRecords(originalProps,skus);
    int totalRecords=skus.size();
    for (int i=0; i < totalRecords; i++) {
      Sku sku=skus.get(i);
      Entity entity=payload[i];
      List<ProductOptionValue> optionValues=sku.getProductOptionValues();
      StringBuilder options=new StringBuilder("");
      for (      ProductOptionValue value : optionValues) {
        if (StringUtils.isNotBlank(options.toString())) {
          options.append("; ");
        }
        options.append(value.getProductOption().getAttributeName()).append(": ").append(value.getAttributeValue());
      }
      Property optionProperty=new Property();
      optionProperty.setName("productOptionList");
      optionProperty.setValue(options.toString());
      entity.addProperty(optionProperty);
    }
    return new DynamicResultSet(payload,totalRecords);
  }
 catch (  Exception e) {
    LOG.error("Unable to execute persistence activity",e);
    throw new ServiceException("Unable to perform fetch for entity: " + ceilingEntityFullyQualifiedClassname,e);
  }
}
