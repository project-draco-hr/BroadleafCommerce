{
  Comparator<Node> hashCompare=new Comparator<Node>(){
    @Override public int compare(    Node arg0,    Node arg1){
      int response=-1;
      if (arg0.isSameNode(arg1)) {
        response=0;
      }
      if (response != 0) {
        boolean eof=false;
        Node parentNode=arg0;
        while (!eof) {
          parentNode=parentNode.getParentNode();
          if (parentNode == null) {
            eof=true;
          }
 else           if (arg1.isSameNode(parentNode)) {
            response=0;
            eof=true;
          }
        }
      }
      return response;
    }
  }
;
  Arrays.sort(exhaustedNodes,hashCompare);
  List<Node> usedNodes=new ArrayList<Node>();
  Iterator<Node> itr=list.iterator();
  while (itr.hasNext()) {
    Node node=itr.next();
    if (Element.class.isAssignableFrom(node.getClass()) && Arrays.binarySearch(exhaustedNodes,node,hashCompare) < 0) {
      if (replaceNode(primaryNodes,node,"id")) {
        usedNodes.add(node);
        continue;
      }
      if (replaceNode(primaryNodes,node,"name")) {
        usedNodes.add(node);
        continue;
      }
      if (exactNodeExists(primaryNodes,node)) {
        usedNodes.add(node);
        continue;
      }
      primaryNodes[0].getParentNode().appendChild(primaryNodes[0].getOwnerDocument().importNode(node.cloneNode(true),true));
      usedNodes.add(node);
    }
  }
  return usedNodes;
}
