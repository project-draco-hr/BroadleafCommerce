{
  SessionFactory sessionFactory=((HibernateEntityManager)entityManager).getSession().getSessionFactory();
  String[] tokens=fieldName.split("\\.");
  Field field=null;
  for (int j=0; j < tokens.length; j++) {
    String propertyName=tokens[j];
    field=getSingleField(clazz,propertyName);
    if (field != null && j < tokens.length - 1) {
      Class<?>[] entities=helper.getAllPolymorphicEntitiesFromCeiling(field.getType(),sessionFactory,true,true);
      if (!ArrayUtils.isEmpty(entities)) {
        String peekAheadToken=tokens[j + 1];
        List<Class<?>> matchedClasses=new ArrayList<Class<?>>();
        for (        Class<?> entity : entities) {
          Field peekAheadField=null;
          try {
            peekAheadField=entity.getDeclaredField(peekAheadToken);
          }
 catch (          NoSuchFieldException nsf) {
          }
          if (peekAheadField != null) {
            matchedClasses.add(entity);
          }
        }
        if (matchedClasses.size() > 1) {
          LOG.warn("Found the property (" + peekAheadToken + ") in more than one class of an inheritance hierarchy. This may lead to unwanted behavior, as the system does not know which class was intended. Do not use the same property name in different levels of the inheritance hierarchy. Defaulting to the first class found ("+ matchedClasses.get(0).getName()+ ")");
        }
        if (matchedClasses.isEmpty()) {
          return null;
        }
        if (getSingleField(matchedClasses.get(0),peekAheadToken) != null) {
          clazz=matchedClasses.get(0);
          Class<?>[] entities2=helper.getAllPolymorphicEntitiesFromCeiling(clazz,sessionFactory,true,true);
          if (!ArrayUtils.isEmpty(entities2) && matchedClasses.size() == 1 && clazz.isInterface()) {
            try {
              clazz=entityConfiguration.lookupEntityClass(field.getType().getName());
            }
 catch (            Exception e) {
            }
          }
        }
 else {
          clazz=field.getType();
        }
      }
 else {
        clazz=field.getType();
      }
    }
 else {
      break;
    }
  }
  if (field != null) {
    field.setAccessible(true);
  }
  return field;
}
