{
synchronized (LOCK_OBJECT) {
    if (IS_LOCKED) {
      if (errorOnConcurrentReIndex) {
        throw new IllegalStateException("More than one thread attempting to concurrently reindex Solr.");
      }
 else {
        LOG.warn("There is more than one thread attempting to concurrently " + "reindex Solr. Failing additional threads gracefully. Check your configuration.");
        return;
      }
    }
 else {
      IS_LOCKED=true;
    }
  }
  try {
    LOG.info("Rebuilding the solr index...");
    StopWatch s=new StopWatch();
    if (SolrContext.isSingleCoreMode()) {
      SolrIndexServiceImpl.this.deleteAllDocuments();
    }
    Object[] pack=saveState();
    try {
      final Long numProducts=productDao.readCountAllActiveProducts();
      if (LOG.isDebugEnabled()) {
        LOG.debug("There are " + numProducts + " total products");
      }
      performCachedOperation(new SolrIndexCachedOperation.CacheOperation(){
        @Override public void execute() throws ServiceException {
          int page=0;
          while ((page * pageSize) < numProducts) {
            buildIncrementalIndex(page,pageSize);
            page++;
          }
        }
      }
);
      optimizeIndex(SolrContext.getReindexServer());
    }
  finally {
      restoreState(pack);
    }
    shs.swapActiveCores();
    if (!SolrContext.isSingleCoreMode()) {
      deleteAllDocuments();
    }
    LOG.info(String.format("Finished building index in %s",s.toLapString()));
  }
  finally {
synchronized (LOCK_OBJECT) {
      IS_LOCKED=false;
    }
  }
}
