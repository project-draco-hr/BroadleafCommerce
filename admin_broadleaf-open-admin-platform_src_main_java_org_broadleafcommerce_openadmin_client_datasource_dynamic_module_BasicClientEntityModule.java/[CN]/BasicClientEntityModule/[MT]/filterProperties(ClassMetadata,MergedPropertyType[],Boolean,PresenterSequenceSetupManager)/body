{
  if (BLCMain.isLogDebugEnabled("classmetadata")) {
    Map<String,List<String>> props=new HashMap<String,List<String>>();
    for (    Property property : metadata.getProperties()) {
      String type=property.getMetadata().getInheritedFromType();
      List<String> myProps=props.get(type);
      if (myProps == null) {
        props.put(type,new ArrayList<String>());
        myProps=props.get(type);
      }
      myProps.add(property.getName());
    }
    for (    String key : props.keySet()) {
      List<String> myProps=props.get(key);
      for (      String prop : myProps) {
        BLCMain.logDebug(key + " : " + prop,"classmetadata");
      }
    }
  }
  Property[] properties=metadata.getProperties();
  if (overrideFieldSort) {
    Arrays.sort(properties,new Comparator<Property>(){
      public int compare(      Property o1,      Property o2){
        if (o1.getMetadata().getFriendlyName() == null && o2.getMetadata().getFriendlyName() == null) {
          return 0;
        }
 else         if (o1.getMetadata().getFriendlyName() == null) {
          return -1;
        }
 else         if (o2.getMetadata().getFriendlyName() == null) {
          return 1;
        }
 else {
          return o1.getMetadata().getFriendlyName().compareTo(o2.getMetadata().getFriendlyName());
        }
      }
    }
);
  }
  for (  final Property property : metadata.getProperties()) {
    property.getMetadata().accept(new MetadataVisitorAdapter(){
      @Override public void visit(      BasicFieldMetadata metadata){
        String mergedPropertyType=metadata.getMergedPropertyType().toString();
        if (Arrays.binarySearch(includeTypes,MergedPropertyType.valueOf(mergedPropertyType)) >= 0) {
          Boolean isDirty=property.getIsDirty();
          String rawName=property.getName();
          String propertyName=rawName;
          String fieldType=metadata.getFieldType() == null ? null : metadata.getFieldType().toString();
          String secondaryFieldType=metadata.getSecondaryType() == null ? null : metadata.getSecondaryType().toString();
          Long length=metadata.getLength() == null ? null : metadata.getLength().longValue();
          Boolean required;
          if (metadata.getRequiredOverride() != null) {
            required=metadata.getRequiredOverride();
          }
 else {
            required=metadata.getRequired();
            if (required == null) {
              required=false;
            }
          }
          Boolean mutable=metadata.getMutable();
          String inheritedFromType=metadata.getInheritedFromType();
          String[] availableToTypes=metadata.getAvailableToTypes();
          String foreignKeyClass=metadata.getForeignKeyClass();
          String foreignKeyProperty=metadata.getForeignKeyProperty();
          String friendlyName=metadata.getFriendlyName();
          if (friendlyName == null || friendlyName.equals("")) {
            friendlyName=property.getName();
          }
 else {
            friendlyName=getLocalizedString(friendlyName);
          }
          String securityLevel=metadata.getSecurityLevel();
          VisibilityEnum visibility=metadata.getVisibility();
          if (visibility == null) {
            visibility=VisibilityEnum.HIDDEN_ALL;
          }
          Boolean hidden=visibility == VisibilityEnum.HIDDEN_ALL || visibility == VisibilityEnum.GRID_HIDDEN;
          FormHiddenEnum formHidden;
switch (visibility) {
case FORM_HIDDEN:
            formHidden=FormHiddenEnum.HIDDEN;
          break;
default :
        formHidden=FormHiddenEnum.NOT_SPECIFIED;
      break;
case GRID_HIDDEN:
    formHidden=FormHiddenEnum.VISIBLE;
  break;
}
String group=metadata.getGroup();
if (group != null && !group.equals("")) {
group=getLocalizedString(group);
}
Integer groupOrder=metadata.getGroupOrder();
Boolean groupCollapsed=metadata.getGroupCollapsed();
String tooltip=metadata.getTooltip();
if (tooltip != null && !tooltip.equals("")) {
tooltip=getLocalizedString(tooltip);
}
String helpText=metadata.getHelpText();
if (helpText != null && !helpText.equals("")) {
helpText=getLocalizedString(helpText);
}
String hint=metadata.getHint();
if (hint != null && !hint.equals("")) {
hint=getLocalizedString(hint);
}
Boolean largeEntry=metadata.isLargeEntry();
Boolean prominent=metadata.isProminent();
Integer order=metadata.getOrder();
String columnWidth=metadata.getColumnWidth();
String[][] enumerationValues=metadata.getEnumerationValues();
String enumerationClass=metadata.getEnumerationClass();
Boolean canEditEnumeration=metadata.getOptionCanEditValues() != null && metadata.getOptionCanEditValues();
if (mutable) {
Boolean isReadOnly=metadata.getReadOnly();
if (isReadOnly != null) {
  mutable=!isReadOnly;
}
}
DataSourceField field;
switch (SupportedFieldType.valueOf(fieldType)) {
case ID:
field=new DataSourceTextField(propertyName,friendlyName);
if (propertyName.indexOf(".") < 0) {
field.setPrimaryKey(true);
}
field.setCanEdit(false);
field.setRequired(required);
break;
case BOOLEAN:
field=new DataSourceBooleanField(propertyName,friendlyName);
field.setCanEdit(mutable);
break;
case DATE:
field=new DataSourceDateTimeField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
field.setEditorType(new MiniDateRangeItem());
break;
case INTEGER:
field=new DataSourceIntegerField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case DECIMAL:
field=new DataSourceFloatField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case EMAIL:
field=new DataSourceTextField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case MONEY:
field=new DataSourceFloatField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case FOREIGN_KEY:
{
field=new DataSourceTextField(propertyName,friendlyName);
field.setCanEdit(mutable);
String dataSourceName=null;
ForeignKey foreignField=(ForeignKey)persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);
if (foreignField != null && foreignField.getForeignKeyClass().equals(foreignKeyClass)) {
dataSourceName=foreignField.getDataSourceName();
}
if (dataSourceName == null) {
field.setForeignKey(foreignKeyProperty);
}
 else {
field.setForeignKey(dataSourceName + "." + foreignKeyProperty);
}
if (hidden == null) {
hidden=true;
}
field.setRequired(required);
break;
}
case ADDITIONAL_FOREIGN_KEY:
{
field=new DataSourceTextField(propertyName,friendlyName);
field.setCanEdit(mutable);
if (hidden == null) {
hidden=true;
}
field.setRequired(required);
if (metadata.getForeignKeyDisplayValueProperty() != null) {
ForeignKey foreignKey=new ForeignKey(foreignKeyProperty,foreignKeyClass);
foreignKey.setDisplayValueProperty(metadata.getForeignKeyDisplayValueProperty());
LookupMetadata lookupMetadata=new LookupMetadata();
lookupMetadata.setLookupForeignKey(foreignKey);
lookupMetadata.setParentDataSourceName(metadata.getLookupParentDataSourceName());
lookupMetadata.setTargetDynamicFormDisplayId(metadata.getTargetDynamicFormDisplayId());
lookupMetadata.setFriendlyName(friendlyName);
lookupMetadata.setFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
DynamicEntityPresenter.lookupMetadatas.put(presenterSequenceSetupManager.getPresenter().getClass().getName() + "_" + property.getName(),lookupMetadata);
}
break;
}
case BROADLEAF_ENUMERATION:
{
if (canEditEnumeration) {
field=new DataSourceTextField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
ComboBoxItem item=new ComboBoxItem();
item.setDefaultToFirstOption(true);
LinkedHashMap<String,String> valueMap=new LinkedHashMap<String,String>();
for (String[] enumerationValue : enumerationValues) {
valueMap.put(enumerationValue[0],enumerationValue[1]);
}
field.setValueMap(valueMap);
field.setEditorType(item);
}
 else {
field=new DataSourceEnumField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
LinkedHashMap<String,String> valueMap=new LinkedHashMap<String,String>();
for (String[] enumerationValue : enumerationValues) {
valueMap.put(enumerationValue[0],enumerationValue[1]);
}
field.setValueMap(valueMap);
}
break;
}
case EXPLICIT_ENUMERATION:
{
if (canEditEnumeration) {
field=new DataSourceTextField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
ComboBoxItem item=new ComboBoxItem();
item.setDefaultToFirstOption(true);
LinkedHashMap<String,String> valueMap=new LinkedHashMap<String,String>();
for (String[] enumerationValue : enumerationValues) {
valueMap.put(enumerationValue[0],enumerationValue[1]);
}
field.setValueMap(valueMap);
field.setEditorType(item);
}
 else {
field=new DataSourceEnumField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
LinkedHashMap<String,String> valueMap=new LinkedHashMap<String,String>();
for (String[] enumerationValue : enumerationValues) {
valueMap.put(enumerationValue[0],enumerationValue[1]);
}
field.setValueMap(valueMap);
}
break;
}
case DATA_DRIVEN_ENUMERATION:
{
if (canEditEnumeration) {
field=new DataSourceTextField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
ComboBoxItem item=new ComboBoxItem();
item.setDefaultToFirstOption(true);
LinkedHashMap<String,String> valueMap=new LinkedHashMap<String,String>();
for (String[] enumerationValue : enumerationValues) {
valueMap.put(enumerationValue[0],enumerationValue[1]);
}
field.setValueMap(valueMap);
field.setEditorType(item);
}
 else {
field=new DataSourceEnumField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
LinkedHashMap<String,String> valueMap=new LinkedHashMap<String,String>();
for (String[] enumerationValue : enumerationValues) {
valueMap.put(enumerationValue[0],enumerationValue[1]);
}
field.setValueMap(valueMap);
}
break;
}
case PASSWORD:
field=new DataSourcePasswordField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case ASSET:
field=new DataSourceImageField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
default :
field=new DataSourceTextField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
}
field.setAttribute("friendlyName",friendlyName);
if (metadata.getValidationConfigurations().size() > 0) {
field.setValidators(ValidationFactoryManager.getInstance().createValidators(metadata.getValidationConfigurations(),propertyName));
}
if (fieldType.equals(SupportedFieldType.ID.toString())) {
field.setHidden(hidden);
field.setAttribute("permanentlyHidden",hidden);
formHidden=FormHiddenEnum.VISIBLE;
}
 else if (hidden != null) {
field.setHidden(hidden);
field.setAttribute("permanentlyHidden",hidden);
}
 else if (field.getAttribute("permanentlyHidden") == null) {
field.setHidden(false);
field.setAttribute("permanentlyHidden",false);
}
if (securityLevel != null && !"".equals(securityLevel)) {
String uniqueID=ceilingEntityFullyQualifiedClassname + field.getName();
org.broadleafcommerce.openadmin.client.security.SecurityManager.getInstance().registerField(uniqueID,securityLevel);
field.setAttribute("uniqueID",uniqueID);
field.setAttribute("securityLevel",securityLevel);
}
field.setAttribute("formHidden",formHidden);
if (group != null) {
field.setAttribute("formGroup",group);
}
if (groupOrder != null) {
field.setAttribute("formGroupOrder",groupOrder);
}
if (groupCollapsed != null) {
field.setAttribute("formGroupCollapsed",groupCollapsed);
}
if (tooltip != null) {
field.setPrompt(tooltip);
}
if (helpText != null) {
field.setAttribute("helpText",helpText);
}
if (hint != null) {
field.setAttribute("hint",hint);
}
if (largeEntry != null) {
field.setAttribute("largeEntry",largeEntry);
}
if (prominent != null) {
field.setAttribute("prominent",prominent);
}
if (order != null) {
field.setAttribute("presentationLayerOrder",order);
}
if (length != null) {
field.setLength(length.intValue());
}
if (columnWidth != null) {
field.setAttribute("columnWidth",columnWidth);
}
if (enumerationValues != null) {
field.setAttribute("enumerationValues",enumerationValues);
}
if (enumerationClass != null) {
field.setAttribute("enumerationClass",enumerationClass);
}
field.setAttribute("canEditEnumeration",canEditEnumeration);
if (isDirty != null) {
field.setAttribute("isEdited",isDirty);
}
 else {
field.setAttribute("isEdited",false);
}
field.setAttribute("inheritedFromType",inheritedFromType);
field.setAttribute("availableToTypes",availableToTypes);
field.setAttribute("fieldType",fieldType);
field.setAttribute("secondaryFieldType",secondaryFieldType);
field.setAttribute("mergedPropertyType",mergedPropertyType);
field.setAttribute("rawName",rawName);
dataSource.addField(field);
}
}
@Override public void visit(final BasicCollectionMetadata metadata){
if (presenterSequenceSetupManager != null) {
DynamicEntityPresenter.collectionMetadatas.put(presenterSequenceSetupManager.getPresenter().getClass().getName() + "_" + property.getName(),metadata);
}
}
@Override public void visit(AdornedTargetCollectionMetadata metadata){
if (presenterSequenceSetupManager != null) {
DynamicEntityPresenter.collectionMetadatas.put(presenterSequenceSetupManager.getPresenter().getClass().getName() + "_" + property.getName(),metadata);
}
}
@Override public void visit(MapMetadata metadata){
if (presenterSequenceSetupManager != null) {
DynamicEntityPresenter.collectionMetadatas.put(presenterSequenceSetupManager.getPresenter().getClass().getName() + "_" + property.getName(),metadata);
}
}
}
);
}
dataSource.setAttribute("blcCurrencyCode",metadata.getCurrencyCode(),true);
}
