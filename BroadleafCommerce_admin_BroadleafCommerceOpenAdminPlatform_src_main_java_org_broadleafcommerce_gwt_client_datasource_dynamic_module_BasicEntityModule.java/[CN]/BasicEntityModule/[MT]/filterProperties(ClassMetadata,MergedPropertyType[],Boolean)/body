{
  Property[] properties=metadata.getProperties();
  if (overrideFieldSort) {
    Arrays.sort(properties,new Comparator<Property>(){
      public int compare(      Property o1,      Property o2){
        if (o1.getMetadata().getPresentationAttributes().getFriendlyName() == null && o2.getMetadata().getPresentationAttributes().getFriendlyName() == null) {
          return 0;
        }
 else         if (o1.getMetadata().getPresentationAttributes().getFriendlyName() == null) {
          return -1;
        }
 else         if (o2.getMetadata().getPresentationAttributes().getFriendlyName() == null) {
          return 1;
        }
 else {
          return o1.getMetadata().getPresentationAttributes().getFriendlyName().compareTo(o2.getMetadata().getPresentationAttributes().getFriendlyName());
        }
      }
    }
);
  }
  for (  Property property : metadata.getProperties()) {
    String mergedPropertyType=property.getMetadata().getMergedPropertyType().toString();
    if (Arrays.binarySearch(includeTypes,MergedPropertyType.valueOf(mergedPropertyType)) >= 0) {
      String rawName=property.getName();
      String propertyName=rawName;
      String fieldType=property.getMetadata().getFieldType() == null ? null : property.getMetadata().getFieldType().toString();
      String secondaryFieldType=property.getMetadata().getSecondaryType() == null ? null : property.getMetadata().getSecondaryType().toString();
      Long length=property.getMetadata().getLength() == null ? null : property.getMetadata().getLength().longValue();
      Boolean required=property.getMetadata().getRequired();
      if (required == null) {
        required=false;
      }
      Boolean mutable=property.getMetadata().getMutable();
      String inheritedFromType=property.getMetadata().getInheritedFromType();
      String[] availableToTypes=property.getMetadata().getAvailableToTypes();
      String foreignKeyClass=property.getMetadata().getForeignKeyClass();
      String foreignKeyProperty=property.getMetadata().getForeignKeyProperty();
      String friendlyName=property.getMetadata().getPresentationAttributes().getFriendlyName();
      if (friendlyName == null) {
        friendlyName=property.getName();
      }
      Boolean hidden=property.getMetadata().getPresentationAttributes().isHidden();
      String group=property.getMetadata().getPresentationAttributes().getGroup();
      Integer groupOrder=property.getMetadata().getPresentationAttributes().getGroupOrder();
      Boolean largeEntry=property.getMetadata().getPresentationAttributes().isLargeEntry();
      Boolean prominent=property.getMetadata().getPresentationAttributes().isProminent();
      Integer order=property.getMetadata().getPresentationAttributes().getOrder();
      String columnWidth=property.getMetadata().getPresentationAttributes().getColumnWidth();
      String[][] enumerationValues=property.getMetadata().getEnumerationValues();
      String enumerationClass=property.getMetadata().getEnumerationClass();
      if (mutable) {
        Boolean isReadOnly=property.getMetadata().getPresentationAttributes().getReadOnly();
        if (isReadOnly != null) {
          mutable=!isReadOnly;
        }
      }
      DataSourceField field;
switch (SupportedFieldType.valueOf(fieldType)) {
case ID:
        field=new DataSourceTextField(propertyName,friendlyName);
      if (propertyName.indexOf(".") < 0) {
        field.setPrimaryKey(true);
      }
    field.setCanEdit(false);
  hidden=true;
field.setRequired(required);
break;
case BOOLEAN:
field=new DataSourceBooleanField(propertyName,friendlyName);
field.setCanEdit(mutable);
break;
case DATE:
field=new DataSourceDateTimeField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case INTEGER:
field=new DataSourceIntegerField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case DECIMAL:
field=new DataSourceFloatField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case EMAIL:
field=new DataSourceTextField(propertyName,friendlyName);
field.setValidators(Validators.EMAIL);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case MONEY:
field=new DataSourceFloatField(propertyName,friendlyName);
field.setValidators(Validators.USCURRENCY);
field.setCanEdit(mutable);
field.setRequired(required);
break;
case FOREIGN_KEY:
{
field=new DataSourceTextField(propertyName,friendlyName);
String dataSourceName=null;
ForeignKey foreignField=(ForeignKey)persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);
if (foreignField != null && foreignField.getForeignKeyClass().equals(foreignKeyClass)) {
dataSourceName=foreignField.getDataSourceName();
}
if (dataSourceName == null) {
field.setForeignKey(foreignKeyProperty);
}
 else {
field.setForeignKey(dataSourceName + "." + foreignKeyProperty);
}
if (hidden == null) {
hidden=true;
}
field.setRequired(required);
break;
}
case ADDITIONAL_FOREIGN_KEY:
{
field=new DataSourceTextField(propertyName,friendlyName);
if (hidden == null) {
hidden=true;
}
field.setRequired(required);
break;
}
case BROADLEAF_ENUMERATION:
field=new DataSourceEnumField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
LinkedHashMap<String,String> valueMap=new LinkedHashMap<String,String>();
for (int j=0; j < enumerationValues.length; j++) {
valueMap.put(enumerationValues[j][0],enumerationValues[j][1]);
}
field.setValueMap(valueMap);
break;
default :
field=new DataSourceTextField(propertyName,friendlyName);
field.setCanEdit(mutable);
field.setRequired(required);
break;
}
if (fieldType.equals(SupportedFieldType.ID.toString())) {
field.setHidden(true);
field.setAttribute("permanentlyHidden",false);
}
 else if (hidden != null) {
field.setHidden(hidden);
field.setAttribute("permanentlyHidden",hidden);
}
 else if (field.getAttribute("permanentlyHidden") == null) {
field.setHidden(false);
field.setAttribute("permanentlyHidden",false);
}
if (group != null) {
field.setAttribute("formGroup",group);
}
if (groupOrder != null) {
field.setAttribute("formGroupOrder",groupOrder);
}
if (largeEntry != null) {
field.setAttribute("largeEntry",largeEntry);
}
if (prominent != null) {
field.setAttribute("prominent",prominent);
}
if (order != null) {
field.setAttribute("presentationLayerOrder",order);
}
if (length != null) {
field.setLength(length.intValue());
}
if (columnWidth != null) {
field.setAttribute("columnWidth",columnWidth);
}
if (enumerationValues != null) {
field.setAttribute("enumerationValues",enumerationValues);
}
if (enumerationClass != null) {
field.setAttribute("enumerationClass",enumerationClass);
}
field.setAttribute("inheritedFromType",inheritedFromType);
field.setAttribute("availableToTypes",availableToTypes);
field.setAttribute("fieldType",fieldType);
field.setAttribute("secondaryFieldType",secondaryFieldType);
field.setAttribute("mergedPropertyType",mergedPropertyType);
field.setAttribute("rawName",rawName);
dataSource.addField(field);
}
}
}
