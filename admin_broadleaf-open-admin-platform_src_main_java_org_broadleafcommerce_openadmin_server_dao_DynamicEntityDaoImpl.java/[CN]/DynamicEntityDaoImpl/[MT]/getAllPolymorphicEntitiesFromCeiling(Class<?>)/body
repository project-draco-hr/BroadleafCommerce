{
  Class<?>[] cache;
synchronized (LOCK_OBJECT) {
    cache=POLYMORPHIC_ENTITY_CACHE.get(ceilingClass);
    if (cache == null) {
      List<Class<?>> entities=new ArrayList<Class<?>>();
      for (      Object item : getSessionFactory().getAllClassMetadata().values()) {
        ClassMetadata metadata=(ClassMetadata)item;
        Class<?> mappedClass=metadata.getMappedClass(EntityMode.POJO);
        if (mappedClass != null && ceilingClass.isAssignableFrom(mappedClass)) {
          entities.add(mappedClass);
        }
      }
      Class<?>[] sortedEntities=new Class<?>[entities.size()];
      List<Class<?>> stageItems=new ArrayList<Class<?>>();
      stageItems.add(ceilingClass);
      int j=0;
      while (j < sortedEntities.length) {
        List<Class<?>> newStageItems=new ArrayList<Class<?>>();
        boolean topLevelClassFound=false;
        for (        Class<?> stageItem : stageItems) {
          Iterator<Class<?>> itr=entities.iterator();
          while (itr.hasNext()) {
            Class<?> entity=itr.next();
            checkitem: {
              if (ArrayUtils.contains(entity.getInterfaces(),stageItem) || entity.equals(stageItem)) {
                topLevelClassFound=true;
                break checkitem;
              }
              if (topLevelClassFound) {
                continue;
              }
              if (entity.getSuperclass().equals(stageItem)) {
                break checkitem;
              }
              continue;
            }
            sortedEntities[j]=entity;
            itr.remove();
            j++;
            newStageItems.add(entity);
          }
        }
        if (newStageItems.isEmpty()) {
          throw new IllegalArgumentException("There was a gap in the inheritance hierarchy for (" + ceilingClass.getName() + ")");
        }
        stageItems=newStageItems;
      }
      ArrayUtils.reverse(sortedEntities);
      cache=sortedEntities;
      POLYMORPHIC_ENTITY_CACHE.put(ceilingClass,sortedEntities);
    }
  }
  return cache;
}
