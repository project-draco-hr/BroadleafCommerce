{
  MapMetadata metadata=new MapMetadata();
  metadata.setMutable(map.mutable());
  org.broadleafcommerce.openadmin.client.dto.OperationTypes dtoOperationTypes=new org.broadleafcommerce.openadmin.client.dto.OperationTypes(OperationType.MAP,OperationType.MAP,OperationType.MAP,OperationType.MAP,OperationType.MAP);
  if (field.getAnnotation(AdminPresentationOperationTypes.class) != null) {
    AdminPresentationOperationTypes operationTypes=field.getAnnotation(AdminPresentationOperationTypes.class);
    dtoOperationTypes.setRemoveType(operationTypes.removeType());
    dtoOperationTypes.setAddType(operationTypes.addType());
    dtoOperationTypes.setInspectType(operationTypes.inspectType());
    dtoOperationTypes.setUpdateType(operationTypes.updateType());
    dtoOperationTypes.setFetchType(operationTypes.fetchType());
  }
  PersistencePerspective persistencePerspective=new PersistencePerspective(dtoOperationTypes,new String[]{},new ForeignKey[]{});
  metadata.setPersistencePerspective(persistencePerspective);
  String parentObjectClass=targetClass.getName();
  Map idMetadata=getIdMetadata(targetClass);
  String parentObjectIdField=(String)idMetadata.get("name");
  String keyClassName;
  checkProperty: {
    if (!String.class.equals(map.keyClass())) {
      keyClassName=map.keyClass().getName();
      break checkProperty;
    }
    java.lang.reflect.Type type=field.getGenericType();
    if (type instanceof ParameterizedType) {
      ParameterizedType pType=(ParameterizedType)type;
      Class<?> clazz=(Class<?>)pType.getActualTypeArguments()[0];
      if (!ArrayUtils.isEmpty(getAllPolymorphicEntitiesFromCeiling(clazz))) {
        throw new RuntimeException("Key class for AdminPresentationMap was determined to be a JPA managed type. Only primitive types for the key type are currently supported.");
      }
      keyClassName=clazz.getName();
      break checkProperty;
    }
    keyClassName=String.class.getName();
  }
  String keyPropertyName="key";
  String keyPropertyFriendlyName=map.keyPropertyFriendlyName();
  boolean deleteEntityUponRemove=map.deleteEntityUponRemove();
  String valuePropertyName="value";
  String valuePropertyFriendlyName=map.valuePropertyFriendlyName();
  metadata.setMediaField(map.mediaField());
  checkProperty: {
    if (!void.class.equals(map.valueClass())) {
      metadata.setValueClassName(map.valueClass().getName());
      break checkProperty;
    }
    java.lang.reflect.Type type=field.getGenericType();
    if (type instanceof ParameterizedType) {
      ParameterizedType pType=(ParameterizedType)type;
      Class<?> clazz=(Class<?>)pType.getActualTypeArguments()[1];
      Class<?>[] entities=getAllPolymorphicEntitiesFromCeiling(clazz);
      if (!ArrayUtils.isEmpty(entities)) {
        metadata.setValueClassName(entities[entities.length - 1].getName());
        break checkProperty;
      }
    }
    ManyToMany manyToMany=field.getAnnotation(ManyToMany.class);
    if (manyToMany != null && !StringUtils.isEmpty(manyToMany.targetEntity().getName())) {
      metadata.setValueClassName(manyToMany.mappedBy());
      break checkProperty;
    }
    metadata.setValueClassName(String.class.getName());
  }
  checkProperty: {
    java.lang.reflect.Type type=field.getGenericType();
    if (type instanceof ParameterizedType) {
      ParameterizedType pType=(ParameterizedType)type;
      Class<?> clazz=(Class<?>)pType.getActualTypeArguments()[1];
      Class<?>[] entities=getAllPolymorphicEntitiesFromCeiling(clazz);
      if (!ArrayUtils.isEmpty(entities)) {
        metadata.setSimpleValue(false);
        break checkProperty;
      }
    }
    ManyToMany manyToMany=field.getAnnotation(ManyToMany.class);
    if (manyToMany != null && !StringUtils.isEmpty(manyToMany.targetEntity().getName())) {
      metadata.setSimpleValue(false);
      break checkProperty;
    }
    metadata.setSimpleValue(map.isSimpleValue());
  }
  if (!ArrayUtils.isEmpty(map.keys())) {
    String[][] keys=new String[map.keys().length][2];
    int j=0;
    for (    AdminPresentationMapKey mapKey : map.keys()) {
      keys[j][0]=mapKey.keyName();
      keys[j][1]=mapKey.friendlyKeyName();
      j++;
    }
    metadata.setKeys(keys);
  }
  if (!void.class.equals(map.mapKeyOptionEntityClass())) {
    metadata.setMapKeyOptionEntityClass(map.mapKeyOptionEntityClass().getName());
  }
 else {
    metadata.setMapKeyOptionEntityClass("");
  }
  metadata.setMapKeyOptionEntityDisplayField(map.mapKeyOptionEntityDisplayField());
  metadata.setMapKeyOptionEntityValueField(map.mapKeyOptionEntityValueField());
  if (ArrayUtils.isEmpty(metadata.getKeys()) && (StringUtils.isEmpty(metadata.getMapKeyOptionEntityClass()) || StringUtils.isEmpty(metadata.getMapKeyOptionEntityValueField()) || StringUtils.isEmpty(metadata.getMapKeyOptionEntityDisplayField()))) {
    throw new RuntimeException("Could not ascertain method for generating key options for the annotated map (" + field.getName() + "). Must specify either an array of AdminPresentationMapKey values for the keys property, or utilize the mapOptionKeyClass, mapOptionKeyDisplayField and mapOptionKeyValueField properties");
  }
  ForeignKey foreignKey=new ForeignKey(parentObjectIdField,parentObjectClass);
  MapStructure mapStructure;
  persistencePerspective.addPersistencePerspectiveItem(PersistencePerspectiveItemType.FOREIGNKEY,foreignKey);
  if (metadata.isSimpleValue()) {
    mapStructure=new SimpleValueMapStructure(keyClassName,keyPropertyName,keyPropertyFriendlyName,metadata.getValueClassName(),valuePropertyName,valuePropertyFriendlyName,field.getName());
  }
 else {
    mapStructure=new MapStructure(keyClassName,keyPropertyName,keyPropertyFriendlyName,metadata.getValueClassName(),field.getName(),deleteEntityUponRemove);
  }
  persistencePerspective.addPersistencePerspectiveItem(PersistencePerspectiveItemType.MAPSTRUCTURE,mapStructure);
  metadata.setExcluded(map.excluded());
  metadata.setFriendlyName(map.friendlyName());
  metadata.setSecurityLevel(map.securityLevel());
  metadata.setOrder(map.order());
  if (!StringUtils.isEmpty(map.targetUIElementId())) {
    metadata.setTargetElementId(map.targetUIElementId());
  }
  if (!StringUtils.isEmpty(map.dataSourceName())) {
    metadata.setDataSourceName(map.dataSourceName());
  }
  metadata.setCustomCriteria(map.customCriteria());
  attributes.put(field.getName(),metadata);
}
