{
  int j=0;
  Comparator<String> propertyComparator=new Comparator<String>(){
    @Override public int compare(    String o1,    String o2){
      if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {
        return 0;
      }
      return o1.compareTo(o2);
    }
  }
;
  List<String> presentationKeyList=new ArrayList<String>(presentationAttributes.keySet());
  Collections.sort(presentationKeyList);
  for (  String propertyName : propertyNames) {
    final Type type=propertyTypes.get(j);
    boolean isPropertyForeignKey=testForeignProperty(foreignField,prefix,propertyName);
    int additionalForeignKeyIndexPosition=findAdditionalForeignKeyIndex(additionalForeignFields,prefix,propertyName);
    j++;
    Field myField=getFieldManager().getField(targetClass,propertyName);
    if (myField == null) {
      myField=getFieldManager().getField(targetClass,prefix + propertyName);
    }
    if (!type.isAnyType() && !type.isCollectionType() || isPropertyForeignKey || additionalForeignKeyIndexPosition >= 0 || Collections.binarySearch(presentationKeyList,propertyName,propertyComparator) >= 0) {
      if (myField != null) {
        boolean handled=false;
        for (        PropertyProvider provider : propertyProviders) {
          if (provider.canHandleField(myField)) {
            FieldMetadata presentationAttribute=presentationAttributes.get(propertyName);
            if (presentationAttribute != null) {
              setExcludedBasedOnShowIfProperty(presentationAttribute);
            }
            provider.buildProperty(myField,targetClass,foreignField,additionalForeignFields,mergedPropertyType,componentProperties,fields,idProperty,prefix,propertyName,type,isPropertyForeignKey,additionalForeignKeyIndexPosition,presentationAttributes,presentationAttribute,null,type.getReturnedClass(),this);
            handled=true;
          }
        }
        if (!handled) {
          buildBasicProperty(myField,targetClass,foreignField,additionalForeignFields,additionalNonPersistentProperties,mergedPropertyType,presentationAttributes,componentProperties,fields,idProperty,populateManyToOneFields,includeFields,excludeFields,configurationKey,ceilingEntityFullyQualifiedClassname,parentClasses,prefix,isParentExcluded,propertyName,type,isPropertyForeignKey,additionalForeignKeyIndexPosition);
        }
      }
    }
  }
}
