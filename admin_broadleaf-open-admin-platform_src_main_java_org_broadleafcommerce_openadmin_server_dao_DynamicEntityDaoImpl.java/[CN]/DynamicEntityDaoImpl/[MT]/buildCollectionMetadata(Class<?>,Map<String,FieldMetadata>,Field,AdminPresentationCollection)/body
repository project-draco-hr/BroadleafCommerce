{
  BasicCollectionMetadata metadata=new BasicCollectionMetadata();
  metadata.setMutable(annotColl.mutable());
  metadata.setAddType(annotColl.addType());
  org.broadleafcommerce.openadmin.client.dto.OperationTypes dtoOperationTypes=new org.broadleafcommerce.openadmin.client.dto.OperationTypes();
  if (field.getAnnotation(AdminPresentationOperationTypes.class) != null) {
    AdminPresentationOperationTypes operationTypes=field.getAnnotation(AdminPresentationOperationTypes.class);
    dtoOperationTypes.setRemoveType(operationTypes.removeType());
    dtoOperationTypes.setAddType(operationTypes.addType());
    dtoOperationTypes.setInspectType(operationTypes.inspectType());
    dtoOperationTypes.setUpdateType(operationTypes.updateType());
    dtoOperationTypes.setFetchType(operationTypes.fetchType());
  }
  if (annotColl.addType() == AddType.LOOKUP) {
    dtoOperationTypes.setRemoveType(OperationType.NONDESTRUCTIVEREMOVE);
  }
  PersistencePerspective persistencePerspective=new PersistencePerspective(dtoOperationTypes,new String[]{},new ForeignKey[]{});
  metadata.setPersistencePerspective(persistencePerspective);
  String foreignKeyName=null;
  OneToMany oneToMany=field.getAnnotation(OneToMany.class);
  ManyToMany manyToMany=field.getAnnotation(ManyToMany.class);
  checkForeignKeyName: {
    if (!StringUtils.isEmpty(annotColl.manyToField())) {
      foreignKeyName=annotColl.manyToField();
      break checkForeignKeyName;
    }
    if (oneToMany != null && !StringUtils.isEmpty(oneToMany.mappedBy())) {
      foreignKeyName=oneToMany.mappedBy();
      break checkForeignKeyName;
    }
    if (manyToMany != null && !StringUtils.isEmpty(manyToMany.mappedBy())) {
      foreignKeyName=manyToMany.mappedBy();
      break checkForeignKeyName;
    }
    if (StringUtils.isEmpty(foreignKeyName)) {
      throw new IllegalArgumentException("Unable to infer a ManyToOne field name for the @AdminPresentationCollection annotated field(" + field.getName() + "). If not using the mappedBy property of @OneToMany or @ManyToMany, please make sure to explicitly define the manyToField property");
    }
  }
  ForeignKey foreignKey=new ForeignKey(foreignKeyName,targetClass.getName(),null,ForeignKeyRestrictionType.ID_EQ);
  persistencePerspective.addPersistencePerspectiveItem(PersistencePerspectiveItemType.FOREIGNKEY,foreignKey);
  String ceiling=null;
  checkCeiling: {
    if (oneToMany != null && oneToMany.targetEntity() != void.class) {
      ceiling=oneToMany.targetEntity().getName();
      break checkCeiling;
    }
    if (manyToMany != null && manyToMany.targetEntity() != void.class) {
      ceiling=manyToMany.targetEntity().getName();
      break checkCeiling;
    }
  }
  if (!StringUtils.isEmpty(ceiling)) {
    metadata.setCollectionCeilingEntity(ceiling);
  }
  metadata.setExcluded(annotColl.excluded());
  metadata.setFriendlyName(annotColl.friendlyName());
  metadata.setSecurityLevel(annotColl.securityLevel());
  metadata.setOrder(annotColl.order());
  if (!StringUtils.isEmpty(annotColl.targetUIElementId())) {
    metadata.setTargetElementId(annotColl.targetUIElementId());
  }
  if (!StringUtils.isEmpty(annotColl.dataSourceName())) {
    metadata.setDataSourceName(annotColl.dataSourceName());
  }
  metadata.setCustomCriteria(annotColl.customCriteria());
  attributes.put(field.getName(),metadata);
}
